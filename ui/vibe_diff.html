<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vibe Patch Diff UI</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: sans-serif; }
    body        { display: flex; flex-direction: column; }
    #toolbar    { display: flex; align-items: center; gap: 6px; padding: 8px; background: #add8e6; border-bottom: 1px solid #ccc; flex-wrap: wrap; }
    #currentFileNameDisplay { margin-left: 10px; font-weight: bold; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 250px; }
    #versionDisplay { margin-left: auto; font-style: italic; padding-right: 10px; white-space: nowrap; }
    label { margin-left: 10px; }
    input[type=number] { width: 50px; }
    button { cursor: pointer; }

    #main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column; /* Toolbar, Tabs, Content Area */
      overflow: hidden;
    }

    /* --- Tab Navigation --- */
    #tab-nav {
      display: flex;
      flex-shrink: 0; /* Prevent tabs from shrinking */
      border-bottom: 1px solid #ccc;
      padding: 5px 5px 0 5px;
      background-color: #f0f0f0; /* Light grey background */
    }
    .tab-button {
      padding: 8px 15px;
      border: 1px solid #ccc;
      border-bottom: none; /* Remove bottom border */
      margin-right: 4px;
      background-color: #e9e9e9; /* Slightly darker inactive */
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      font-size: 0.9em;
      position: relative;
      bottom: -1px; /* Align with content border */
    }
    .tab-button.active {
      background-color: #fff; /* White active tab */
      border-bottom: 1px solid #fff; /* Hide bottom border matching content area */
      font-weight: bold;
    }

    /* --- Tab Content Area --- */
    #tab-content-area {
      flex: 1 1 auto; /* Takes remaining vertical space */
      overflow: hidden; /* Hide overflow */
      position: relative;
      background-color: #fff; /* White background */
      border-top: 1px solid #ccc; /* Separator, matches tab bottom for active */
    }
    .tab-pane {
      display: none; /* Hide inactive panes */
      width: 100%;
      height: 100%; /* Fill the content area */
      box-sizing: border-box;
      overflow: hidden; /* Prevent scrollbars on pane itself */
    }
    .tab-pane.active {
      display: flex; /* Use flex for the active pane's layout */
    }

    /* --- Diff Tab Content --- */
    #diff-tab-content {
       flex-direction: column; /* Stack children vertically (only child is #diff) */
    }
    #diff { /* Diff editor takes all space in its tab */
        flex: 1 1 auto;
        overflow: hidden;
        border: none;
    }

    /* --- LLM Patch Tab Content --- */
    #llm-patch-tab-content {
        flex-direction: column; /* Stack children vertically (only child is #patchContainer) */
        overflow: hidden;
    }
    #patchContainer { /* Container for prompt/patch side-by-side */
        flex: 1 1 auto; /* Takes all space within its tab pane */
        display: flex;
        flex-direction: row;
        gap: 5px;
        padding: 5px;
        box-sizing: border-box;
        overflow: hidden;
        border: none;
        min-height: 150px; /* Minimum size */
    }
    .prompt-section,
    .patch-section {
        flex: 1; /* Share horizontal space */
        display: flex;
        min-width: 150px; /* Minimum width for each section */
        overflow: hidden; /* Prevent content from overflowing sections */
    }
    .prompt-section {
        flex-direction: column; /* Stack label, textarea, button, status vertically */
        padding-right: 5px; /* Spacing from vertical drag bar */
    }
    .prompt-section label {
        margin-left: 0; margin-bottom: 4px; font-weight: bold; flex-shrink: 0;
    }
    .prompt-section textarea {
        flex-grow: 1; width: 100%; box-sizing: border-box; resize: vertical;
        margin-bottom: 4px; min-height: 50px;
    }
    .prompt-section button {
        padding: 6px 10px; align-self: flex-start; margin-top: auto; /* Pushes button to bottom */
        margin-bottom: 2px; flex-shrink: 0;
    }
    #llm-status {
        margin-top: 2px; font-style: italic; color: grey; font-size: 0.9em;
        min-height: 1.1em; flex-shrink: 0;
    }
    .patch-section {
        flex-direction: row; /* Layout: Buttons | Drag | Editor */
        padding-left: 5px; /* Spacing from vertical drag bar */
    }
    #patchBtns {
        flex: 0 0 100px; display:flex; flex-direction:column; gap:4px; padding:4px;
        box-sizing:border-box; background:#f4f4f4; min-width: 60px;
    }
    #patchBtns button {
        width:100%; min-height:32px; cursor:pointer;
    }
    #dragV {
        flex:0 0 4px; background:#ccc; cursor:col-resize;
    }
    #patchEditor {
        flex-grow: 1; /* Takes remaining horizontal space */
        min-width: 100px;
        height: 100%; /* Fill vertical space of .patch-section */
        overflow: hidden; /* Monaco handles internal scroll */
    }

  </style>
  <!-- Monaco Loader -->
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs/loader.js"></script>
</head>
<body>
  <div id="toolbar">
    <button id="loadFileBtn" title="Load a different Python file manually">Load File</button>
    <span id="currentFileNameDisplay" title="Currently loaded file">No file loaded</span>
    <button id="loadPatchBtn" title="Load a .vibe patch file" disabled>Load Patch</button>
    <button id="acceptBtn" title="Apply changes from right pane and save as new Head" disabled>Apply</button>
    <button id="prevBtn" title="View previous version or cancel preview" disabled>Previous</button>
    <button id="nextBtn" title="View next version (towards Head)" disabled>Next</button>
    <button id="copyPromptBtn" title="Copy Vibe System Prompt to clipboard">Copy Prompt</button>
    <label for="backupLimitInput">Backups:</label>
    <input type="number" id="backupLimitInput" value="20" min="0" title="Max backups to keep (0=unlimited)">
    <div id="versionDisplay">Head</div>
    <input type="file" id="fileInput1" accept=".py" style="display:none" />
    <input type="file" id="fileInput2" accept=".vibe,.txt" style="display:none" />
  </div>

  <div id="main">
    <div id="tab-nav">
      <button class="tab-button active" data-tab="diff-tab-content">Diff View</button>
      <button class="tab-button" data-tab="llm-patch-tab-content">LLM Patch</button>
    </div>
    <div id="tab-content-area">
      <div id="diff-tab-content" class="tab-pane active">
        <div id="diff"></div>
      </div>
      <div id="llm-patch-tab-content" class="tab-pane">
        <div id="patchContainer">
          <div class="prompt-section">
            <label for="llm-prompt-input">LLM Prompt:</label>
            <textarea id="llm-prompt-input" placeholder="Describe the patch you want..."></textarea>
            <button id="generate-patch-btn">Generate Patch</button>
            <div id="llm-status"></div>
          </div>
          <div class="patch-section">
            <div id="patchBtns">
              <button id="clearPatchBtn" title="Clear patch text and revert preview">Clear</button>
              <button id="applyPatchBtn" title="Preview changes from patch editor" disabled>Preview Patch</button>
            </div>
            <div id="dragV"></div>
            <div id="patchEditor"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs' } });
  </script>
  <script>
    require(['vs/editor/editor.main'], () => {
      const qs = id => document.getElementById(id);
      const loadFileBtn    = qs('loadFileBtn');
      const currentFileNameDisplay = qs('currentFileNameDisplay');
      const loadPatchBtn   = qs('loadPatchBtn');
      const applyBtnToolbar= qs('acceptBtn');
      const prevBtn        = qs('prevBtn');
      const nextBtn        = qs('nextBtn');
      const copyPromptBtn  = qs('copyPromptBtn');
      const backupLimitInput = qs('backupLimitInput');
      const versionDisplay = qs('versionDisplay');
      const fileInput1     = qs('fileInput1');
      const fileInput2     = qs('fileInput2');

      const diffContainer  = qs('diff');
      const patchEditorContainer = qs('patchEditor');
      const llmPromptInput = qs('llm-prompt-input');
      const generatePatchBtn = qs('generate-patch-btn');
      const llmStatusDiv = qs('llm-status');
      const clearBtnPatchArea = qs('clearPatchBtn');
      const previewBtnPatchArea = qs('applyPatchBtn');

      let diffEditor;
      let patchEditor;
      try {
           diffEditor = monaco.editor.createDiffEditor(diffContainer, { readOnly: true, renderSideBySide: true, enableSplitViewResizing: true, automaticLayout: true, originalEditable: false });
           diffEditor.setModel({ original: monaco.editor.createModel('', 'python'), modified: monaco.editor.createModel('', 'python') });
           patchEditor = monaco.editor.create(patchEditorContainer, { language: 'yaml', theme: 'vs', automaticLayout: true, minimap: { enabled: false } });
      } catch (e) {
          console.error("Failed to initialize Monaco editors:", e); alert("Error initializing code editors.");
          document.querySelectorAll('#toolbar button, #patchBtns button, .tab-button').forEach(btn => btn.disabled = true); return;
      }

      let headText = '';
      let compareText = '';
      let patchText = '';
      let currentFile = '';
      let versions = [];
      let versionIndex = 0;
      let previewActive = false;
      let previewTargetFile = '';

      const tabButtons = document.querySelectorAll('.tab-button');
      const tabPanes = document.querySelectorAll('.tab-pane');

      tabButtons.forEach(button => {
          button.addEventListener('click', () => {
              tabButtons.forEach(btn => btn.classList.remove('active'));
              tabPanes.forEach(pane => pane.classList.remove('active'));
              button.classList.add('active');
              const targetTabPaneId = button.getAttribute('data-tab');
              const targetPane = document.getElementById(targetTabPaneId);
              if (targetPane) {
                  targetPane.classList.add('active');
                  if (targetTabPaneId === 'diff-tab-content' && diffEditor) {
                      diffEditor.layout();
                  } else if (targetTabPaneId === 'llm-patch-tab-content' && patchEditor) {
                      patchEditor.layout();
                  }
              }
          });
      });

      const checkLlmAvailability = async () => {
          if (!generatePatchBtn || !llmPromptInput || !llmStatusDiv) {
              console.warn("LLM UI elements for status check not found.");
              return;
          }
          try {
              const response = await fetch('/llm/status');
              if (!response.ok) {
                  throw new Error(`HTTP error fetching LLM status: ${response.status}`);
              }
              const data = await response.json();
              if (data.configured === true) {
                  generatePatchBtn.disabled = false;
                  llmPromptInput.disabled = false;
                  if (llmStatusDiv.textContent.includes("not available") || llmStatusDiv.textContent.includes("Error checking")) {
                     llmStatusDiv.textContent = "";
                  }
              } else {
                  generatePatchBtn.disabled = true;
                  llmPromptInput.disabled = true;
                  llmStatusDiv.textContent = "LLM generation is not available on the server.";
                  console.warn("LLM generation disabled: Server reports not configured.");
              }
          } catch (error) {
              console.error("Failed to check LLM availability:", error);
              generatePatchBtn.disabled = true;
              llmPromptInput.disabled = true;
              llmStatusDiv.textContent = "Error checking LLM availability.";
          }
      };

      if (generatePatchBtn && llmPromptInput && llmStatusDiv && patchEditor) {
          generatePatchBtn.addEventListener('click', async () => {
              const userPrompt = llmPromptInput.value.trim();
              if (!userPrompt) {
                  llmStatusDiv.textContent = 'Please enter a prompt.';
                  return;
              }
              patchEditor.setValue('');
              llmStatusDiv.textContent = 'Generating patch...';
              generatePatchBtn.disabled = true;
              llmPromptInput.disabled = true;
              try {
                  const payload = {
                      prompt: userPrompt,
                      filename: currentFile || "",
                      file_content: headText || ""
                  };
                  console.log("Sending to /generate-patch:", payload);

                  const response = await fetch('/generate-patch', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(payload),
                  });
                  const data = await response.json();
                  if (!response.ok) {
                      throw new Error(data.error || `HTTP error! status: ${response.status}`);
                  }
                  patchEditor.setValue(data.patch_content || '# No content received.');
                  llmStatusDiv.textContent = 'Patch generated.';
              } catch (error) {
                  console.error('Error generating patch:', error);
                  llmStatusDiv.textContent = `Error: ${error.message}`;
                  patchEditor.setValue(`# Error generating patch:\n# ${error.message}`);
              } finally {
                  await checkLlmAvailability();
                  if (!generatePatchBtn.disabled) {
                    llmPromptInput.disabled = false;
                  }
                  updateNav();
              }
          });
      } else {
          console.warn("One or more LLM UI elements not found for binding click event, or button is disabled.");
          if (generatePatchBtn) generatePatchBtn.disabled = true;
      }

      const setDiff = (orig, mod) => {
        if (!diffEditor) return;
        try {
            diffEditor.getModel()?.original.setValue(orig ?? '');
            diffEditor.getModel()?.modified.setValue(mod ?? '');
            setTimeout(() => { if (diffEditor) diffEditor.layout(); }, 0);
        } catch (e) {
            console.error("Error setting diff model:", e);
            toast("Error updating the diff view.", "error");
        }
      };

      const toast = (msg, level = 'error') => {
        if (console && console[level]) { console[level](msg); } else { console.log(`[${level}] ${msg}`); }
        alert(msg);
      };

      (function(){
        let startX, startW; const dragV = qs('dragV'); const btns = qs('patchBtns');
        const patchCont = qs('patchContainer');
        if (!dragV || !btns || !patchCont || !dragV.parentElement || dragV.parentElement.parentElement !== patchCont) {
             return;
        }
        dragV.addEventListener('mousedown', e => {
            startX = e.clientX; startW = btns.offsetWidth;
            document.body.style.cursor = 'col-resize';
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
        });
        function onMove(e) {
            const delta = e.clientX - startX;
            const patchContainerWidth = patchCont.offsetWidth;
            const minEditorWidth = 100 + 4;
            const newW = Math.min(patchContainerWidth - minEditorWidth, Math.max(60, startW + delta));
            btns.style.flexBasis = newW + 'px';
        }
        function onUp() {
            document.body.style.cursor = '';
            window.removeEventListener('mousemove', onMove);
            window.removeEventListener('mouseup', onUp);
        }
      })();

      const updateNav = () => {
        if (!patchEditor || !currentFileNameDisplay) return;
        patchText = patchEditor.getValue() ?? '';
        const isAtHead = versionIndex === versions.length;
        const hasVersions = versions.length > 0;
        const hasPatchText = patchText.trim().length > 0;
        const changesExist = compareText !== headText;

        currentFileNameDisplay.textContent = currentFile || 'No file loaded';
        currentFileNameDisplay.title = currentFile || 'No file loaded';

        loadFileBtn.disabled = false;
        prevBtn.disabled = !(previewActive || (hasVersions && (versionIndex === versions.length || versionIndex < versions.length - 1)));
        nextBtn.disabled = !( !previewActive && hasVersions && !isAtHead );
        applyBtnToolbar.disabled = !changesExist;
        loadPatchBtn.disabled = !currentFile;
        previewBtnPatchArea.disabled = !hasPatchText;
        clearBtnPatchArea.disabled = !hasPatchText;

        let versionLabel = 'Head';
        if (previewActive) {
            versionLabel = `Preview (${previewTargetFile || 'new file'})`;
        } else if (!isAtHead && versions[versionIndex]) {
            const ver = versions[versionIndex];
            const shortSha = (ver.type === 'backup') ? ver.sha : (ver.sha?.substring(0, 7) || 'Unknown');
            versionLabel = `${ver.type || 'Ver'} ${shortSha}`;
        }
        versionDisplay.textContent = versionLabel;
      };

      const fetchVersions = async () => {
        if (!currentFile) { versions = []; versionIndex = 0; updateNav(); return; }
        try {
          const r = await fetch(`/versions?file=${encodeURIComponent(currentFile)}`);
          if (!r.ok) throw new Error(`HTTP ${r.status} fetching versions: ${await r.text()}`);
          versions = await r.json() || [];
          versions.sort((a, b) => (b.date || '').localeCompare(a.date || ''));
        } catch (e) {
          toast(`Failed to fetch versions: ${e.message}`, 'warn'); versions = [];
        }
        versionIndex = versions.length; updateNav();
      };
      const loadFileContent = async (filename) => {
          if (!filename) { toast('No file specified to load.', 'error'); return null; }
          try {
            const r = await fetch(`/file?file=${encodeURIComponent(filename)}`);
            if (!r.ok) throw new Error(`HTTP ${r.status} loading file: ${await r.text()}`);
            return await r.text();
           } catch (e) { toast(`Failed to load file '${filename}': ${e.message}`, 'error'); return null; }
      };
      const loadVersionContent = async (filename, sha) => {
           if (!filename || !sha) { toast('File or Version SHA missing.', 'error'); return null; }
           try {
            const r = await fetch(`/version?file=${encodeURIComponent(filename)}&sha=${encodeURIComponent(sha)}`);
            if (!r.ok) throw new Error(`HTTP ${r.status} loading version: ${await r.text()}`);
            return await r.text();
           } catch (e) { toast(`Failed to load version ${sha}: ${e.message}`, 'error'); return null; }
      };

      const loadHeadState = async () => {
          if (!currentFile) return;
          const content = await loadFileContent(currentFile);
          if (content !== null) {
              headText = content; compareText = content;
              setDiff(headText, compareText);
              previewActive = false; previewTargetFile = currentFile;
              versionIndex = versions.length; updateNav();
          } else { toast(`Failed to load HEAD content for ${currentFile}.`, 'error'); }
      };
const loadVersionState = async (index) => {
    if (index < 0 || index >= versions.length || !versions[index] || !currentFile) return;
    const version = versions[index]; const sha = version.sha;
    const currentHeadContent = await loadFileContent(currentFile);
    if (currentHeadContent === null) { toast(`Failed to reload HEAD for version ${sha}.`, 'error'); return; }
    headText = currentHeadContent;
    const versionContent = await loadVersionContent(currentFile, sha);
    if (versionContent !== null) {
        compareText = versionContent; setDiff(headText, compareText);
        previewActive = false; previewTargetFile = currentFile;
        versionIndex = index; updateNav();
    } else { toast(`Failed to load content for version ${sha}.`, 'error'); await loadHeadState(); }
};

      const previewPatch = async () => {
        patchText = patchEditor.getValue() ?? '';
        if (!patchText.trim()) {
            if (versionIndex === versions.length) await loadHeadState(); else await loadVersionState(versionIndex);
            return;
        }
        if (!currentFile) { toast("Cannot preview patch, no base file loaded.", 'warn'); return; }
        console.log("previewPatch: currentFile =", currentFile);
        console.log("previewPatch: patchText being sent to /apply:\n", patchText);
        try {
          const currentHeadContent = await loadFileContent(currentFile);
          headText = currentHeadContent ?? '';
          const response = await fetch('/apply', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ patch: patchText, file: currentFile })
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${await response.text()}`);
          const results = await response.json();
          if (!results || typeof results !== 'object' || Object.keys(results).length === 0) throw new Error("Invalid patch response.");
          const resultFiles = Object.keys(results);
          let targetFile = resultFiles[0]; let appliedContent = results[targetFile];
          if (resultFiles.length > 1 && results.hasOwnProperty(currentFile)) {
              targetFile = currentFile; appliedContent = results[currentFile];
          }
          if (typeof appliedContent !== 'string') throw new Error("Patch content not string.");
          compareText = appliedContent; previewTargetFile = targetFile; previewActive = true;
          setDiff(headText, compareText); updateNav();

          const diffViewTabButton = document.querySelector('.tab-button[data-tab="diff-tab-content"]');
          if (diffViewTabButton && !diffViewTabButton.classList.contains('active')) {
              diffViewTabButton.click();
          } else if (diffViewTabButton && diffViewTabButton.classList.contains('active')) {
              if (diffEditor) diffEditor.layout();
          }
        } catch(e) { toast(`Patch preview failed: ${e.message}`, 'error'); }
      };

      copyPromptBtn.onclick = () => {
          const systemPromptText = `# VibePatchGPT System Prompt

You are **VibePatchGPT**, an assistant that speaks **only** in valid Vibe Patch files. You support **VibeSpec v1.6** (multi‑patch bundles and decorator handling) and all patch types from v1.4+. When the user asks for a patch, output **only** the \`.vibe\` YAML+code content—no explanations, no extra text. Always provide patches in a yaml code block.

---

## Spec Summary

1.  **Header**
    Every file must begin with:
    \`\`\`yaml
    # VibeSpec: 1.6
    \`\`\`

2.  **Patch Sections**
    Each patch starts at a line beginning with \`patch_type:\`. Metadata lines follow until \`--- code:\`. Everything indented under \`--- code:\` is the literal code block.

### Metadata Keys

-   \`patch_type\`: one of:
    -   \`add_function\`, \`replace_function\`, \`remove_function\`
    -   \`add_method\`, \`replace_method\`, \`remove_method\`
    -   \`add_class\`, \`replace_class\`, \`remove_class\`
    -   \`add_block\`, \`remove_block\`
-   \`file\`: relative path to the target file
-   \`class\`: required for method patches
-   \`name\`: required for named removals (\`remove_*\`)
-   \`position\`: for \`add_block\` (\`start\`, \`end\`, \`before\`, \`after\`)
-   \`anchor\`: for \`add_block\` before/after
-   \`anchor_start\` & \`anchor_end\`: for \`remove_block\` by range

### Code Block

\`\`\`yaml
--- code: |
    <exact code snippet>
\`\`\`

---
(Include relevant examples from your prompt file here if desired)
---

Always output only the patch YAML content. No extra text.
`;
          navigator.clipboard.writeText(systemPromptText)
            .then(() => console.log('System prompt copied.'))
            .catch(err => toast('Failed to copy prompt: ' + err, 'error'));
      };

       const loadInitialFile = async () => {
           if (typeof window.INITIAL_FILE === 'string' && window.INITIAL_FILE) {
               currentFile = window.INITIAL_FILE; previewTargetFile = currentFile;
               const initialContent = await loadFileContent(currentFile);
               if (initialContent !== null) {
                   headText = initialContent; compareText = initialContent;
                   setDiff(headText, compareText); patchEditor.setValue(''); previewActive = false;
                   loadPatchBtn.disabled = false; await fetchVersions();
               } else {
                   toast(`Error autoloading '${currentFile}'. Load manually.`, 'error');
                   currentFile = headText = compareText = previewTargetFile = '';
                   versions = []; versionIndex = 0; previewActive = false; loadPatchBtn.disabled = true;
                   setDiff('', ''); updateNav();
               }
           } else { updateNav(); }
           updateNav();
       };

      patchEditor.setValue('');
      loadFileBtn.onclick = () => fileInput1.click();
      fileInput1.onchange = async e => {
          const f = e.target.files[0]; if (!f) return;
          try {
            const text = await f.text(); currentFile = f.name; previewTargetFile = currentFile;
            headText = text; compareText = text; patchEditor.setValue(''); previewActive = false;
            setDiff(headText, headText); loadPatchBtn.disabled = false; await fetchVersions();
          } catch (err) {
            toast(`Error loading selected file: ${err.message}`, 'error');
            currentFile = headText = compareText = previewTargetFile = ''; versions = []; versionIndex = 0;
            previewActive = false; loadPatchBtn.disabled = true; setDiff('', ''); updateNav();
          } finally { e.target.value = null; }
      };
      loadPatchBtn.onclick = () => { if (!loadPatchBtn.disabled) fileInput2.click(); };
      fileInput2.onchange = async e => {
          const f = e.target.files[0]; if (!f) return;
          try {
            const txt = await f.text(); patchEditor.setValue(txt); updateNav(); await previewPatch();
          } catch (err) { toast(`Error loading patch file: ${err.message}`, 'error'); }
          finally { e.target.value = null; }
      };
      patchEditor.onDidChangeModelContent(() => { updateNav(); });

      clearBtnPatchArea.onclick = () => {
          patchEditor.setValue('');
          if (previewActive) {
              if (versionIndex === versions.length) loadHeadState(); else loadVersionState(versionIndex);
          } else { updateNav(); }
          patchEditor.focus();
      };
      previewBtnPatchArea.onclick = previewPatch;

prevBtn.onclick = () => {
    if (previewActive) {
        clearBtnPatchArea.onclick();
    } else if (versionIndex === versions.length) {
        // From Head to most recent backup
        loadVersionState(0);
    } else if (versionIndex < versions.length - 1) {
        // From backup to next older backup
        loadVersionState(versionIndex + 1);
    }
    // else do nothing (at oldest backup)
};
nextBtn.onclick = () => {
    if (!previewActive && versions.length > 0 && versionIndex < versions.length) {
        if (versionIndex === 0) {
            // At most recent backup, next goes to Head
            loadHeadState();
        } else {
            // Move toward more recent backup (lower index)
            loadVersionState(versionIndex - 1);
        }
    }
};
      applyBtnToolbar.onclick = async () => {
        const fileToSave = previewActive ? previewTargetFile : currentFile;
        const contentToSave = compareText;
        if (!fileToSave) { toast("Target filename unknown.", 'warn'); return; }
        try {
            const backupLimit = parseInt(backupLimitInput.value, 10);
            const payload = { file: fileToSave, text: contentToSave, backupLimit: isNaN(backupLimit) || backupLimit < 0 ? 20 : backupLimit };
            const r = await fetch('/accept_changes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!r.ok) {
                let errorMsg = `HTTP ${r.status}`; try { const errData = await r.json(); errorMsg += `: ${errData.error || await r.text()}`; } catch { errorMsg += `: ${await r.text()}`; }
                throw new Error(errorMsg);
            }
            if (fileToSave !== currentFile) { currentFile = fileToSave; headText = contentToSave; }
            else { headText = contentToSave; }
            compareText = headText; patchEditor.setValue(''); previewActive = false; previewTargetFile = currentFile;
            setDiff(headText, headText); await fetchVersions();
        } catch (e) { toast(`Apply failed: ${e.message}`, 'error'); }
      };

      updateNav();
      checkLlmAvailability();
      loadInitialFile();

      setTimeout(() => {
        if (qs('diff-tab-content').classList.contains('active') && diffEditor) {
          // diffEditor.layout();
        }
      }, 100);
    });
  </script>
</body>
</html>
