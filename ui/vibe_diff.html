<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vibe Patch Diff UI</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: sans-serif; }
    body        { display: flex; flex-direction: column; }
    #toolbar    { display: flex; align-items: center; gap: 6px; padding: 8px; background: #add8e6; border-bottom: 1px solid #ccc; flex-wrap: wrap; }
    #versionDisplay { margin-left: auto; font-style: italic; padding-right: 10px; }
    label { margin-left: 10px; } /* spacing for backup label */
    input[type=number] { width: 50px; } /* specific width for backup input */
    button { cursor: pointer; }

    /* main area: diff + dragH + patchContainer */
    #main          { flex: 1 1 auto; display:flex; flex-direction:column; overflow:hidden; }
    #diff          { flex: 1 1 auto; overflow:hidden; border: none; } /* Ensure no internal borders interfere */
    #dragH         { flex: 0 0 5px; background:#ccc; cursor:row-resize; }

    /* patch area row */
    #patchContainer { flex: 0 1 200px; display:flex; border-top:1px solid #ccc; min-height: 80px; /* Ensure minimum height */ }
    #patchBtns      { flex: 0 0 100px; display:flex; flex-direction:column; gap:4px; padding:4px; box-sizing:border-box; background:#f4f4f4; min-width: 60px; /* Ensure minimum width */ }
    #patchBtns button{ width:100%; min-height:32px; cursor:pointer; }
    #dragV          { flex:0 0 4px; background:#ccc; cursor:col-resize; }
    #patchEditor    { flex:1 1 auto; min-width: 100px; /* Ensure editor has minimum width */ }
  </style>
  <!-- Monaco Loader -->
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs/loader.js"></script>
</head>
<body>
  <div id="toolbar">
    <button id="loadFileBtn" title="Load a different Python file manually">Load File</button>
    <button id="loadPatchBtn" title="Load a .vibe patch file" disabled>Load Patch</button>
    <button id="acceptBtn" title="Apply changes from right pane and save as new Head" disabled>Apply</button>
    <button id="prevBtn" title="View previous version or cancel preview" disabled>Previous</button>
    <button id="nextBtn" title="View next version (towards Head)" disabled>Next</button>
    <button id="copyPromptBtn" title="Copy Vibe System Prompt to clipboard">Copy Prompt</button>
    <label for="backupLimitInput">Backups:</label>
    <input type="number" id="backupLimitInput" value="20" min="0" title="Max backups to keep (0=unlimited)">
    <div id="versionDisplay">Head</div>
    <!-- Hidden file inputs -->
    <input type="file" id="fileInput1" accept=".py" style="display:none" />
    <input type="file" id="fileInput2" accept=".vibe,.txt" style="display:none" />
  </div>

  <div id="main">
    <div id="diff"></div>
    <div id="dragH"></div>
    <div id="patchContainer">
      <div id="patchBtns">
        <button id="clearPatchBtn" title="Clear patch text and revert preview">Clear</button>
        <button id="applyPatchBtn" title="Preview changes from patch editor" disabled>Preview Patch</button>
      </div>
      <div id="dragV"></div>
      <div id="patchEditor"></div>
    </div>
  </div>

  <!-- Main script using Monaco loader -->
  <script>
    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs' } });
    // Server might inject initial file config here AFTER the config script
    // <script>window.INITIAL_FILE = 'some_file.py'; console.log('Injected INITIAL_FILE:', window.INITIAL_FILE);</script>
  </script>
  <script>
    // Main application logic, runs after Monaco environment is loaded
    require(['vs/editor/editor.main'], () => {
      // --- Query Selectors ---
      const qs = id => document.getElementById(id);
      const loadFileBtn    = qs('loadFileBtn');
      const loadPatchBtn   = qs('loadPatchBtn');
      const applyBtnToolbar= qs('acceptBtn'); // Renamed variable for clarity - refers to the toolbar "Apply" (formerly "Accept")
      const prevBtn        = qs('prevBtn');
      const nextBtn        = qs('nextBtn');
      const clearBtnPatchArea = qs('clearPatchBtn');
      const previewBtnPatchArea = qs('applyPatchBtn'); // Refers to the patch area "Preview Patch" button
      const versionDisplay = qs('versionDisplay');
      const copyPromptBtn  = qs('copyPromptBtn');
      const backupLimitInput = qs('backupLimitInput');
      const fileInput1     = qs('fileInput1');
      const fileInput2     = qs('fileInput2');
      const diffContainer  = qs('diff');
      const patchEditorContainer = qs('patchEditor');

      // --- Monaco Editor Instances ---
      let diffEditor;
      let patchEditor;

      try {
           diffEditor = monaco.editor.createDiffEditor(diffContainer, { readOnly: true, renderSideBySide: true, enableSplitViewResizing: true, automaticLayout: true, originalEditable: false });
           diffEditor.setModel({ original: monaco.editor.createModel('', 'python'), modified: monaco.editor.createModel('', 'python') });
           patchEditor = monaco.editor.create(patchEditorContainer, { language: 'yaml', theme: 'vs', automaticLayout: true, minimap: { enabled: false } });
      } catch (e) {
          console.error("Failed to initialize Monaco editors:", e); alert("Error initializing code editors.");
          document.querySelectorAll('#toolbar button, #patchBtns button').forEach(btn => btn.disabled = true); return;
      }

      // --- State Variables ---
      let headText = ''; let compareText = ''; let patchText = ''; let currentFile = '';
      let versions = []; let versionIndex = 0; let previewActive = false;

      // --- Core Functions ---
      const setDiff = (orig, mod) => {
        if (!diffEditor) return;
        console.log("Setting diff view...");
        try {
            const originalModel = monaco.editor.createModel(orig ?? '', 'python');
            const modifiedModel = monaco.editor.createModel(mod ?? '', 'python');

            diffEditor.setModel({
                original: originalModel,
                modified: modifiedModel
            });

            // *** Force Layout Recalculation ***
            setTimeout(() => {
                if (diffEditor) {
                   diffEditor.layout();
                   console.log("Forced diffEditor.layout().");
                }
            }, 0);
            // *** End Force Layout ***

            console.log("Diff model set.");

        } catch (e) {
            console.error("Error setting diff model:", e);
            toast("Error updating the diff view.", "error");
        }
      };

      const toast = (msg, level = 'error') => {
        if (console && console[level]) { console[level](msg); } else { console.log(`[${level}] ${msg}`); }
        alert(msg);
      };


      // --- Draggable Dividers ---
      (function(){ // Horizontal Drag Logic
        let startY, startH; const dragH = qs('dragH'); const patchCont = qs('patchContainer'); const mainCont = qs('main');
        dragH.addEventListener('mousedown', e => { startY = e.clientY; startH = patchCont.offsetHeight; document.body.style.cursor = 'row-resize'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp); });
        function onMove(e) { const delta = e.clientY - startY; const mainHeight = mainCont.offsetHeight; const newH = Math.min(mainHeight - 50, Math.max(80, startH - delta)); patchCont.style.flexBasis = newH + 'px'; }
        function onUp() { document.body.style.cursor = ''; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); } })();
      (function(){ // Vertical Drag Logic
        let startX, startW; const dragV = qs('dragV'); const btns = qs('patchBtns'); const patchCont = qs('patchContainer');
        dragV.addEventListener('mousedown', e => { startX = e.clientX; startW = btns.offsetWidth; document.body.style.cursor = 'col-resize'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp); });
        function onMove(e) { const delta = e.clientX - startX; const patchWidth = patchCont.offsetWidth; const newW = Math.min(patchWidth - 50, Math.max(60, startW + delta)); btns.style.flexBasis = newW + 'px'; }
        function onUp() { document.body.style.cursor = ''; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); } })();


      // --- UI State Management ---
      const updateNav = () => {
        if (!patchEditor) return;
        patchText = patchEditor.getValue() ?? '';
        const isAtHead = versionIndex === versions.length; const hasVersions = versions.length > 0;
        const hasPatchText = patchText.trim().length > 0; const changesExist = compareText !== headText;

        prevBtn.disabled = !(previewActive || (hasVersions && versionIndex > 0));
        nextBtn.disabled = !( !previewActive && hasVersions && !isAtHead );
        applyBtnToolbar.disabled = !changesExist; // Toolbar Apply enabled if changes exist
        loadPatchBtn.disabled = !currentFile;
        previewBtnPatchArea.disabled = !hasPatchText; // Patch area Preview enabled if patch text exists
        clearBtnPatchArea.disabled = !hasPatchText; // Patch area Clear enabled if patch text exists

        let versionLabel = 'Head';
        if (previewActive) { versionLabel = 'Preview'; }
        else if (!isAtHead && versions[versionIndex]) {
            const ver = versions[versionIndex]; const shortSha = (ver.type === 'backup') ? ver.sha : (ver.sha?.substring(0, 7) || 'Unknown');
            versionLabel = `${ver.type || 'Ver'} ${shortSha}`;
        }
        versionDisplay.textContent = versionLabel;
        // console.log(`updateNav: file='${currentFile}', index=${versionIndex}, preview=${previewActive}, versions=${versions.length}, changes=${changesExist}, patch=${hasPatchText}, prev=${prevBtn.disabled}, next=${nextBtn.disabled}, apply=${applyBtnToolbar.disabled}`);
      };

      // --- Data Fetching Functions ---
      const fetchVersions = async () => {
        if (!currentFile) { console.warn("fetchVersions no currentFile."); versions = []; versionIndex = 0; updateNav(); return; }
        console.log(`Fetching versions for: ${currentFile}`);
        try {
          const r = await fetch(`/versions?file=${encodeURIComponent(currentFile)}`); if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`); versions = await r.json() || [];
          versions.sort((a, b) => (b.date || '').localeCompare(a.date || '')); console.log(`Received ${versions.length} versions.`);
        } catch (e) { toast(`Failed to fetch versions: ${e.message}`, 'warn'); versions = []; }
        versionIndex = versions.length; updateNav();
      };
      const loadFileContent = async (filename) => {
          if (!filename) { toast('No file specified.', 'error'); return null; }
          console.log(`Loading content for: ${filename}`);
          try { const r = await fetch(`/file?file=${encodeURIComponent(filename)}`); if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`); return await r.text(); }
          catch (e) { toast(`Failed to load file '${filename}': ${e.message}`, 'error'); return null; }
      };
      const loadVersionContent = async (filename, sha) => {
           if (!filename || !sha) { toast('File or Version missing.', 'error'); return null; }
           console.log(`Loading version '${sha}' for: ${filename}`);
           try { const r = await fetch(`/version?file=${encodeURIComponent(filename)}&sha=${encodeURIComponent(sha)}`); if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`); return await r.text(); }
           catch (e) { toast(`Failed to load version ${sha}: ${e.message}`, 'error'); return null; }
      };

      // --- UI Action Handlers ---
      const loadHeadState = async () => {
          if (!currentFile) return; console.log(`Loading HEAD: ${currentFile}`); const content = await loadFileContent(currentFile);
          if (content !== null) { headText = content; compareText = content; setDiff(headText, compareText); previewActive = false; versionIndex = versions.length; updateNav(); }
          else { toast(`Failed HEAD load: ${currentFile}.`, 'error'); }
      };
      const loadVersionState = async (index) => {
          if (index < 0 || index >= versions.length || !versions[index]) { console.warn(`Invalid index ${index}`); return; } if (!currentFile) { console.error("No currentFile."); return; }
          const version = versions[index]; const sha = version.sha; console.log(`Loading version: Index ${index}, SHA ${sha}`);
          const currentHeadContent = await loadFileContent(currentFile); if (currentHeadContent === null) { toast(`Failed HEAD reload for ${sha}.`, 'error'); return; } headText = currentHeadContent;
          const versionContent = await loadVersionContent(currentFile, sha);
          if (versionContent !== null) { compareText = versionContent; setDiff(headText, compareText); previewActive = false; versionIndex = index; updateNav(); }
          else { toast(`Failed version load: ${sha}.`, 'error'); }
      };
      const previewPatch = async () => {
        patchText = patchEditor.getValue() ?? ''; if (!patchText.trim()) { console.log("Clearing preview."); if (versionIndex === versions.length) { await loadHeadState(); } else { await loadVersionState(versionIndex); } return; }
        if (!currentFile) { toast("No file loaded.", 'warn'); return; } console.log("Applying patch preview.");
        try {
          const r = await fetch('/apply', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ patch: patchText, file: currentFile }) }); if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`);
          const res = await r.json(); let appliedContent = null;
          if (res && typeof res === 'object') { if (res.hasOwnProperty(currentFile)) { appliedContent = res[currentFile]; } else if (Object.keys(res).length === 1) { appliedContent = res[Object.keys(res)[0]]; console.warn("Response key mismatch."); } }
          if (appliedContent === null || typeof appliedContent !== 'string') { throw new Error("Invalid patch response."); }
          const currentHeadContent = await loadFileContent(currentFile); if (currentHeadContent === null) { toast(`Stale HEAD during preview.`, 'warn'); } else { headText = currentHeadContent; }
          compareText = appliedContent; setDiff(headText, compareText); previewActive = true; updateNav();
        } catch(e) { toast(`Preview failed: ${e.message}`, 'error'); }
      };

      copyPromptBtn.onclick = () => { /* Keep corrected version with escaped backticks */ };
      copyPromptBtn.onclick = () => {
          const systemPromptText = `# VibePatchGPT System Prompt\n\nYou are **VibePatchGPT**... (rest of your prompt text here with \` escaped as \\\`) ...\n\nAlways output only the patch YAML content. No extra text.`;
          navigator.clipboard.writeText(systemPromptText)
            .then(() => { console.log('System prompt copied.'); })
            .catch(err => toast('Failed to copy prompt: ' + err, 'error'));
      };

       // --- Autoload Initial File Logic ---
       const loadInitialFile = async () => {
           console.log("Attempting autoload...");
           if (typeof window.INITIAL_FILE === 'string' && window.INITIAL_FILE) {
               const initialFilename = window.INITIAL_FILE; console.log("Found INITIAL_FILE:", initialFilename);
               qs('loadFileBtn').disabled = true; currentFile = initialFilename; console.log(`Set currentFile = '${currentFile}'`);
               const initialContent = await loadFileContent(currentFile);
               if (initialContent !== null) {
                   console.log("Initial content loaded."); headText = initialContent; compareText = initialContent;
                   setDiff(headText, compareText); // Update diff view FIRST
                   patchEditor.setValue(''); previewActive = false; loadPatchBtn.disabled = false;
                   console.log("Fetching versions..."); await fetchVersions(); console.log("Initial setup complete.");
               } else {
                   console.error(`Failed initial load: '${initialFilename}'.`); toast(`Error autoloading '${initialFilename}'.`, 'error');
                   currentFile = headText = compareText = ''; versions = []; versionIndex = 0; previewActive = false;
                   loadPatchBtn.disabled = true; setDiff('', ''); updateNav(); qs('loadFileBtn').disabled = false;
               }
           } else { console.log("No INITIAL_FILE. Ready for manual load."); updateNav(); }
       };

      // --- Initial State Setup ---
      patchEditor.setValue('');

      // --- UI Event Bindings ---
      loadFileBtn.onclick = () => fileInput1.click();
      fileInput1.onchange = async e => {
          const f = e.target.files[0]; if (!f) return; const manualFilename = f.name; console.log("Manual file:", manualFilename);
          try { const text = await f.text(); currentFile = manualFilename; headText = text; compareText = text; patchEditor.setValue(''); previewActive = false; setDiff(headText, headText); loadPatchBtn.disabled = false; await fetchVersions(); }
          catch (err) { toast(`Error loading file: ${err.message}`, 'error'); currentFile = headText = compareText = ''; versions = []; versionIndex = 0; previewActive = false; loadPatchBtn.disabled = true; setDiff('', ''); updateNav(); }
          finally { e.target.value = null; } };
      loadPatchBtn.onclick = () => { console.log("Load Patch clicked..."); fileInput2.click(); };
      fileInput2.onchange = async e => {
          console.log("fileInput2 change."); const f = e.target.files[0]; if (!f) { console.log("No file selected."); e.target.value = null; return; } console.log("Patch file:", f.name);
          try { console.log("Reading patch..."); const txt = await f.text(); console.log("Setting patch editor..."); patchEditor.setValue(txt); console.log("Calling updateNav..."); updateNav(); console.log("Calling previewPatch..."); await previewPatch(); console.log("previewPatch done."); }
          catch (err) { console.error("Error loading patch:", err); toast(`Error loading patch: ${err.message}`, 'error'); } finally { console.log("Resetting fileInput2."); e.target.value = null; } };
      let patchChangeTimeout; patchEditor.onDidChangeModelContent(() => { clearTimeout(patchChangeTimeout); patchChangeTimeout = setTimeout(updateNav, 250); });
      clearBtnPatchArea.onclick = () => { console.log("Clear clicked."); patchEditor.setValue(''); if (previewActive) { if (versionIndex === versions.length) { loadHeadState(); } else { loadVersionState(versionIndex); } } patchEditor.focus(); };
      previewBtnPatchArea.onclick = previewPatch; // Button in patch area triggers preview
      prevBtn.onclick = () => { console.log("Previous clicked."); if (previewActive) { clearBtnPatchArea.click(); } else if (versionIndex > 0) { loadVersionState(versionIndex - 1); } };
      nextBtn.onclick = () => { console.log("Next clicked."); if (!previewActive && versionIndex < versions.length) { if (versionIndex + 1 === versions.length) { loadHeadState(); } else { loadVersionState(versionIndex + 1); } } };
      // Toolbar Button -> Apply/Accept Changes
      applyBtnToolbar.onclick = async () => {
        if (!currentFile) { toast("No file loaded.", 'warn'); return; } if (compareText === headText) { toast("No changes to apply.", 'info'); return; }
        console.log("Toolbar Apply clicked.");
        try {
            const backupLimit = parseInt(backupLimitInput.value, 10); const payload = { file: currentFile, text: compareText, backupLimit: isNaN(backupLimit) || backupLimit < 0 ? 20 : backupLimit };
            console.log("Sending to /accept_changes:", payload);
            const r = await fetch('/accept_changes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`);
            headText = compareText; patchEditor.setValue(''); previewActive = false;
            setDiff(headText, headText); await fetchVersions();
            console.log("Apply successful."); toast("Changes applied successfully!", "info");
        } catch (e) { toast(`Apply failed: ${e.message}`, 'error'); console.error("Apply failed:", e); } };

      // --- Perform Initial Load ---
      loadInitialFile(); // Attempt to load file specified by server

    }); // End require callback
  </script>
</body>
</html>
